// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// SettingsBTSets settings b t sets
//
// swagger:model settings.BTSets
type SettingsBTSets struct {

	// Cache
	CacheSize int64 `json:"cacheSize,omitempty"`

	// connections limit
	ConnectionsLimit int64 `json:"connectionsLimit,omitempty"`

	// disable d h t
	DisableDHT bool `json:"disableDHT,omitempty"`

	// disable p e x
	DisablePEX bool `json:"disablePEX,omitempty"`

	// disable TCP
	DisableTCP bool `json:"disableTCP,omitempty"`

	// disable u p n p
	DisableUPNP bool `json:"disableUPNP,omitempty"`

	// disable u t p
	DisableUTP bool `json:"disableUTP,omitempty"`

	// disable upload
	DisableUpload bool `json:"disableUpload,omitempty"`

	// in kb, 0 - inf
	DownloadRateLimit int64 `json:"downloadRateLimit,omitempty"`

	// DLNA
	EnableDLNA bool `json:"enableDLNA,omitempty"`

	// debug logs
	EnableDebug bool `json:"enableDebug,omitempty"`

	// BT Config
	EnableIPV6 bool `json:"enableIPv6,omitempty"`

	// Rutor
	EnableRutorSearch bool `json:"enableRutorSearch,omitempty"`

	// Torznab
	EnableTorznabSearch bool `json:"enableTorznabSearch,omitempty"`

	// Torrent
	ForceEncrypt bool `json:"forceEncrypt,omitempty"`

	// friendly name
	FriendlyName string `json:"friendlyName,omitempty"`

	// peers listen port
	PeersListenPort int64 `json:"peersListenPort,omitempty"`

	// in percent
	PreloadCache int64 `json:"preloadCache,omitempty"`

	// in percent, 5%-100%, [...S__X__E...] [S-E] not clean
	ReaderReadAHead int64 `json:"readerReadAHead,omitempty"`

	// remove cache on drop
	RemoveCacheOnDrop bool `json:"removeCacheOnDrop,omitempty"`

	// Reader
	ResponsiveMode bool `json:"responsiveMode,omitempty"`

	// 0 - don`t add, 1 - add retrackers (def), 2 - remove retrackers 3 - replace retrackers
	RetrackersMode int64 `json:"retrackersMode,omitempty"`

	// FS
	ShowFSActiveTorr bool `json:"showFSActiveTorr,omitempty"`

	// ssl cert
	SslCert string `json:"sslCert,omitempty"`

	// ssl key
	SslKey string `json:"sslKey,omitempty"`

	// HTTPS
	SslPort int64 `json:"sslPort,omitempty"`

	// Storage preferences
	StoreSettingsInJSON bool `json:"storeSettingsInJson,omitempty"`

	// store viewed in Json
	StoreViewedInJSON bool `json:"storeViewedInJson,omitempty"`

	// in seconds
	TorrentDisconnectTimeout int64 `json:"torrentDisconnectTimeout,omitempty"`

	// torrents save path
	TorrentsSavePath string `json:"torrentsSavePath,omitempty"`

	// torznab urls
	TorznabUrls []*SettingsTorznabConfig `json:"torznabUrls"`

	// in kb, 0 - inf
	UploadRateLimit int64 `json:"uploadRateLimit,omitempty"`

	// Disk
	UseDisk bool `json:"useDisk,omitempty"`
}

// Validate validates this settings b t sets
func (m *SettingsBTSets) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTorznabUrls(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsBTSets) validateTorznabUrls(formats strfmt.Registry) error {
	if swag.IsZero(m.TorznabUrls) { // not required
		return nil
	}

	for i := 0; i < len(m.TorznabUrls); i++ {
		if swag.IsZero(m.TorznabUrls[i]) { // not required
			continue
		}

		if m.TorznabUrls[i] != nil {
			if err := m.TorznabUrls[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("torznabUrls" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("torznabUrls" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this settings b t sets based on the context it is used
func (m *SettingsBTSets) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTorznabUrls(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsBTSets) contextValidateTorznabUrls(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TorznabUrls); i++ {

		if m.TorznabUrls[i] != nil {

			if swag.IsZero(m.TorznabUrls[i]) { // not required
				return nil
			}

			if err := m.TorznabUrls[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("torznabUrls" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("torznabUrls" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SettingsBTSets) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsBTSets) UnmarshalBinary(b []byte) error {
	var res SettingsBTSets
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
